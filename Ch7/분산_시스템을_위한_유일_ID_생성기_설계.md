# 7장 분산 시스템을 위한 유일 ID 생성기 설계

유일 ID를 생성하기 위해 auto_increment를 사용하려고 할 수도 있지만, 분산 환경에서는 지연시간을 낮추기 어렵고 서버 한 대로는 요구를 감당할 수 없기 때문에 통하지 않는다.

## 7.1 1단계: 문제 이해 및 설계 범위 확정

할 수 있는 질문:

1. ID의 특성 → 유일해야 한다.
2. ID는 항상 1만큼 큰 값이어야 하는지? → 보장할 수 없지만 날짜에 따라 정렬 가능해야 한다.
3. ID는 숫자로만 구성하는지? → 숫자로만 구성해야 하고 64비트로 표현될 수 있어야 한다.
4. 시스템의 규모는 어느 정도 인지? → 초당 10,000개를 만들 수 있어야 한다.

## 7.2 2단계: 개략적 설계안 제시 및 동의 구하기

방법:

- 다중 마스터 복제
- UUID
- 티켓 서버
- 트위터 스노플레이크 접근법

### 7.2.1 다중 마스터 복제

auto_increment를 활용하지만 다음 ID값은 1을 증가시키는 것이 아니라 서버 수(k)만큼 증가시킨다. 서버가 두 대라면 다음 아이디는 전체 서버의 수 2를 더한 값이다. 이러면 규모 확장성 문제를 어느 정도 해결할 수 있다. 초당 생산 가능 ID 수를 늘릴 수 있다.

단점

1. 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다. → 왜지?
2. 시간의 흐름에 맞춰 커지도록 보장할 수 없다.
3. 서버의 추가와 삭제에도 잘 동작하도록 만들기 어렵다.

### 7.2.2 UUID

128비트짜리 수로 만들며 중복 UUID가 생길 확률이 매우 낮다.

장점

1. 만드는 방법이 단순하고 동기화 이슈도 없다.
2. 서버가 알아서 만들기 때문에 규모 확장도 좋다.

단점

1. ID가 128비트로 길다.
2. 시간 순으로 정렬할 수 없다.
3. 숫자가 아닌 값이 포함될 수 있다.

### 7.2.3 티켓 서버

auto_increment기능을 갖춘 디비 서버(티켓 서버)를 중앙 집중형으로 하나를 두고 그것만 사용한다.

장점

1. 유일성이 보장되는 아이디를 쉽게 만들 수 있다.
2. 구현이 쉽고 중소 규모의 앱에 적합하다.

단점

1. 티켓 서버가 SPOF가 된다. 여러 서버를 만들면 데이터 동기화 문제가 발생한다.

### 7.2.4 트위터 스노플레이크 접근법

- 각개 격파 전략(divide and conquer)
    - 사인 비트: 1비트를 할당. 음수와 양수 구별
    - 타임스탬프: 41비트를 할당해서 밀리초가 경과했는지 나타낸다.
    - 데이터 센터 아이디: 5비트를 할당
    - 서버 아이디: 5비트를 할당. 데이터 센터 당 32개의 서버를 사용 가능
    - 일련 번호: 12비트. 아이디를 생성할 때마다 각 서버가 1만큼 증가시키고 1밀리 세컨이 증가할 때마다 0으로 초기화한다.

## 7.3 3단계: 상세 설계

데이터센터 아이디와 서버 아이디는 시스템이 시작할 때 결정되고 운영 중에는 일반적으로 바뀌지 않는다.

### 7.3.1 타임스탬프

시간의 흐름에 따라 점점 큰 값을 갖게 되기 때문에 시간 순으로 정렬 가능해진다.

이 이디 생성 값은 69년동안만 정상 동작하고, 이후에는 기원 시각을 바꾸거나 아이디 체계를 다른 것으로 이전해야 한다.

### 7.3.2 일련 번호

일련번호는 2^12승의 값 까지만 가질 수 있다.

## 7.4 4단계: 마무리

- 시계 동기화: 하나의 서버가 여러 코어에서 실행되는 경우 전부 같은 시계를 쓰지 않을 수도 있는 문제가 있다. 보편적으로 NTP로 이 문제를 해결한다.
- 동시성이 낮고 수명이 길다면 타임스탬프의 길이를 늘리는게 효과적일 수 있다.
- 고가용성: 높은 고가용성이 제공되어야 한다.
