서버를 수평적으로 확장하기 위해서는 데이터를 서버에 균등하게 나누는 것이 중요하고 이를 위해 **안정 해시**를 보편적으로 사용한다.

먼저, 해시 기술로 풀려고 하는 문제를 알아보자.

## 5.1. 해시 키 재배치 (rehash) 문제

N개의 캐시 서버가 있고 부하를 균등하게 나누는 보편적인 방법인 해시 함수를 보자.

```
serverIndex = hash(key) % N (N은 서버의 개수이다.)
```

총 4대의 서버를 사용한다고 했을 때 아래의 표와 같이 서버 인덱스가 결정된다.

| 키 | 해시 | 해시 % 4 (서버 인덱스) |
| --- | --- | --- |
| key0 | 18358617 | 1 |
| key1 | 26143584 | 0 |
| key2 | 18131146 | 2 |
| key3 | 35863496 | 0 |
| key4 | 34085809 | 1 |
| key5 | 27581703 | 3 |
| key6 | 38164978 | 2 |
| key7 | 22530351 | 3 |

이 방법은 서버 풀의 크기가 고정되어 있을 때 잘 동작하지만 서버가 추가되거나 삭제되면 문제가 생긴다. 키에 대한 해시 값은 변하지 않지만 인덱스 값이 달라지며 재분배가 일어나 캐시 클라이언트가 엉뚱한 서버에 접속하게 되어 대규모 캐시 미스가 발생한다.

## 5.2. 안정 해시

안정 해시는 해시 테이블 크기가 조정될 때 평균적으로 오직 k/n개의 키만 재배치하는 해시 기술이다. k는 키의 개수이고, n은 슬롯 개수이다. (? 슬롯이 뭔데?)

전통적인 해시 테이블은 슬롯의 수가 바뀌면 거의 대부분의 키를 재배치한다.

### 5.2.1. 해시 공간과 해시 링

해시 함수로 SHA-1을 쓰고 출력 범위를 x0~xn과 같다고 할 때 해시 공간의 범위는 0~2^160-1 까지이다. 따라서 x0(0) ~ xn(2^160-1) 까지의 값을 갖는다. 이를 bar 형태로 만들어서 링 모양으로 구부리면 원이 완성된다.

### 5.2.2. 해시 서버

해시 함수 f를 사용해서 서버 IP 나 이름을 링 위에 대응시킬 수 있다.

![Untitled](https://github.com/mychum1/system-design-interview/blob/main/Ch5/images/5.01.png)

### 5.2.3. 해시 키

여기서 사용한 해시 함수는 “해시 키 재배치 문제"에 언급된 %를 사용하는 함수와는 다르다.

캐시할 키를 링 위의 어느 지점에 배치한다.

![Untitled](https://github.com/mychum1/system-design-interview/blob/main/Ch5/images/5.02.png)

### 5.2.4. 서버 조회

어떤 키가 저장되는 서버는 키의 위치로부터 시계 방향으로 돌때 만나는 첫 번째 서버다. 따라서 K0은 서버 0에, K1은 서버1에, K2는 서버2에, K3은 서버 3에 저장된다.

### 5.2.5 서버 추가

서버가 추가되어도 키 가운데 일부만 재배치하면 된다. 예를 들어서 K0은 서버 0에 저장되어 있었는데 서버 4가 중간에 생기면서 K0이 서버 4에 저장되어 있으므로 K0만 재배치가 된다.

![Untitled](https://github.com/mychum1/system-design-interview/blob/main/Ch5/images/5.03.png)

### 5.2.6. 서버 제거

서버가 제거되어도 일부의 키만 재배치 된다. 아래의 경우 K1만 서버 1에서 서버 2로 변경된다.

![Untitled](https://github.com/mychum1/system-design-interview/blob/main/Ch5/images/5.04.png)

### 5.2.7 기본 구현법의 두 가지 문제

안정 해시 알고리즘은 MIT에서 처음 제안되었다. 기본 절차는 다음과 같다.

1. 서버와 키를 균등 분포 해시 함수를 사용해 해시 링에 배치한다.
2. 키의 위치에서 링을 시계방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버이다.

이 접근 법에는 2가지 문제가 있다.

1. 서버가 추가되거나 상제되는 상황을 감안하면 파티션의 크기를 균등하게 유지하는게 불가능하다. 여기서 파티션은 인접한 서버 사이의 해시 공간이다. 어느 서버는 굉장히 작은 해시 공간을 할당받고, 어떤 서버는 굉장히 큰 해시 공간을 할당받을 수 있다. 위의 그림에서도 서버1이 사라졌을 때 S0-S2와, S2-S3의 공간 차이가 큰 것을 알 수 있다.
2. 키의 균등 분포를 달성하기 어렵다.

![Untitled](https://github.com/mychum1/system-design-interview/blob/main/Ch5/images/5.05.png)

서버 3은 아무 데이터도 갖지 않지만 대부분의 키는 서버 2에 보관된다. 이를 해결하기 위해 가상 노드 또는 복제(replica)라는 기법이 있다.

### 5.2.8. 가상 노드

가상 노드는 실제 노드 또는 서버를 가리키는 노드이고, 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다. 따라서 각 서버는 하나가 아닌 여러 파티션을 관리해야 한다. 가상 노드의 수가 늘면 점점 키의 분포가 더 균등해지고 표준 편차가 작아진다. 표준 편차는 데이터가 어떻게 퍼져 나갔는지를 보이는 척도이다. 

그러나 가상 노드 데이터를 저장할 공간이 더 많이 필요해져서 tradeoff가 필요하다. 

![Untitled](https://github.com/mychum1/system-design-interview/blob/main/Ch5/images/5.06.png)

서버 0을 하나만 쓰지 않고 0.0, 0.1, 0.2 의 세 개의 가상 노드를 사용했다. s0은 서버 0이 관리하는 파티션이고 s1은 서버 1이 관리하는 파티션이다. 키의 위치로부터 시계 방향으로 탐색하다가 만나는 최초의 가상 노드에 키가 저장된다.

### 5.2.9. 재배치할 키 결정

서버가 추가 혹은 제거되면 데이터의 일부를 재배치해야 한다. 변경된 노드의 반시계 방향에 있는 첫 번째 서버 사이에 있는 데이터들이 재배치가 된다.

1. 노드 추가 : S4~반시계 방향으로 S3까지의 데이터, K0이 재배치 범위에 들어가서 S4로 재배치된다.

![Untitled](https://github.com/mychum1/system-design-interview/blob/main/Ch5/images/5.07.png)

1. 노드 제거 : 삭제된 노드 S1~반시계 방향의 S0 사이의 키들, K1이 S2로 재배치된다.

![Untitled](https://github.com/mychum1/system-design-interview/blob/main/Ch5/images/5.08.png)

## 5.3. 마치며

안정 해시는 다음과 같은 이점을 가진다.

1. 서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.
2. 데이터가 보다 균등하게 분포하게 되어 수평적 규모 확장성을 달성하기 쉽다.
3. 핫스팟 키 문제를 줄인다. 특정 샤드에 접근이 빈번하면 발생하는 문제(유명인으로 인해 몰리는 그런 것들)의 발생 가능성을 줄일 수 있다.

안정 해시는 널리 쓰이는 기술이고 실제 사용 사례 몇 가지는 다음과 같다.

1. 아마존 다이나모 디비 파티셔닝 관련 컴포넌트
2. 아파치 카산드라 클러스터의 데이터 파티셔닝
3. 디스코드 채팅 앱
4. 아카마이 CDN 
5. 매그레프 네트워크 부하 분산기
